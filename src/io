/* vim: set ft=cpp: */
#include <io>

#include <Windows.h>

stream& end(stream& s)
{
	s.flush();
	return s;
}

stream& endl(stream& s)
{
	s.flush();
	s.write("\n", 1);
	return s;
}

out_stream out = out_stream(out_sink);
out_stream err = out_stream(err_sink);
in_stream in = in_stream(in_source);

void out_sink(u8 val[])
{
	usize len = 0;
	while(val[len] != '\0')
		++len;
	
	HANDLE stdout_handle = GetStdHandle(STD_OUTPUT_HANDLE);
	DWORD ret;

	WriteConsoleA(stdout_handle, val, len, &ret, NULL);
}

void err_sink(u8 val[])
{
	usize len = 0;
	while(val[len] != '\0')
		++len;

	HANDLE stderr_handle = GetStdHandle(STD_ERROR_HANDLE);
	DWORD ret;

	WriteConsoleA(stderr_handle, val, len, &ret, NULL);
}

#define IN_SOURCE_BUFFER_LEN 1024

static u8 in_source_buffer[IN_SOURCE_BUFFER_LEN];
static bool capitalized = false;

u8* in_source()
{
	for(usize i = 0; i < IN_SOURCE_BUFFER_LEN; i++) 
	{
		in_source_buffer[i] = 0;
	}
	
	HANDLE stdin_handle = GetStdHandle(STD_INPUT_HANDLE);
	DWORD ret;

	INPUT_RECORD input_record_buffer[IN_SOURCE_BUFFER_LEN];

	//Read one less than maximum so that the end is null (0)
	ReadConsoleInput(stdin_handle, input_record_buffer, IN_SOURCE_BUFFER_LEN - 1, &ret);

	usize read = static_cast<usize>(ret);

	for(usize i = 0, j = 0; i < read; i++)
	{
		if(input_record_buffer[i].EventType == KEY_EVENT)
		{
			bool shift_key = input_record_buffer[i].Event.KeyEvent.wVirtualKeyCode == VK_SHIFT;
			bool shift_state = (input_record_buffer[i].Event.KeyEvent.dwControlKeyState & SHIFT_PRESSED) != 0;
			bool key_down = input_record_buffer[i].Event.KeyEvent.bKeyDown;
			i8 ascii_char = input_record_buffer[i].Event.KeyEvent.uChar.AsciiChar;

			if(shift_state)
			{
				capitalized = key_down;
			}

			if(shift_key)
			{
				continue;
			}

			if(capitalized) {
				ascii_char ^= 0x20;
			}

			in_source_buffer[j++] = ascii_char;
		}
		
	}

	return in_source_buffer;
}

auto out_stream::operator << (string val) -> out_stream& {
	this->write(static_cast<i8 const*>(val), val.length());

	return *this;
}

auto out_stream::operator << (i8 const* val) -> out_stream& {
	this->write(val, strlen(val));

	return *this;
}

auto out_stream::operator << (f32 val) -> out_stream& {
	i8 chars[256] = {};

	dtoa(static_cast<f64>(val), chars, 10);

	this->write(chars, strlen(chars));

	return *this;
}

auto out_stream::operator << (f64 val) -> out_stream& {
	i8 chars[256] = {};

	dtoa(val, chars, 10);

	this->write(chars, strlen(chars));

	return *this;
}

auto out_stream::operator << (stream_op op) -> out_stream& {
	this->apply(op);

	return *this;
}

auto in_stream::operator >> (string& val) -> in_stream& {
	vec<u8> data;

	bool ret = false;

	while(!ret) 
	{
		this->flush();
		while(this->buffer.length() > 0) 
		{
			u8 byte = this->buffer.pop();

			if (byte == '\r') 
			{
				ret = true;
				break;
			} 
			else if(byte == '\0') 
			{
				continue;
			} 
			else 
			{
				out << reinterpret_cast<i8 const*>(&byte) << end;
				data.push(byte);
			}
		}
	}

	out << endl;
	
	data.push('\0');

	u8 const* bytes = static_cast<u8 const*>(data);

	i8 const* chars = reinterpret_cast<i8 const*>(bytes);

	val = string(chars);

	return *this;
}
