/* vim: set ft=cpp: */
#include <io>

#include <Windows.h>

const i8* endl = "\r\n";

out_stream out = out_stream(out_sink);
in_stream in = in_stream(in_source);

void out_sink(u8 val[])
{
	usize len = 0;
	while(val[len] != '\0')
		++len;
	
	HANDLE stdout_handle = GetStdHandle(STD_OUTPUT_HANDLE);
	DWORD ret;

	WriteConsoleA(stdout_handle, val, len, &ret, NULL);
}

void err_sink(u8 val[])
{
	usize len = 0;
	while(val[len] != '\0')
		++len;

	HANDLE stderr_handle = GetStdHandle(STD_ERROR_HANDLE);
	DWORD ret;

	WriteConsoleA(stderr_handle, val, len, &ret, NULL);
}

#define IN_SOURCE_BUFFER_LEN 1024

static u8 in_source_buffer[IN_SOURCE_BUFFER_LEN];

u8* in_source()
{
	for(usize i = 0; i < IN_SOURCE_BUFFER_LEN; i++) 
	{
		in_source_buffer[i] = 0;
	}
	
	HANDLE stdin_handle = GetStdHandle(STD_INPUT_HANDLE);
	DWORD ret;

	INPUT_RECORD input_record_buffer[IN_SOURCE_BUFFER_LEN];

	//Read one less than maximum so that the end is null (0)
	ReadConsoleInput(stdin_handle, input_record_buffer, IN_SOURCE_BUFFER_LEN - 1, &ret);

	usize read = static_cast<usize>(ret);

	usize j = 0;
	for(usize i = 0; i < read; i++)
	{
		if(input_record_buffer[i].EventType == KEY_EVENT)
		{
			in_source_buffer[j++] = 
				input_record_buffer[i].Event.KeyEvent.uChar.AsciiChar;
		}
	}

	return in_source_buffer;
}

auto out_stream::operator << (string val) -> out_stream& {
	this->write(static_cast<i8 const*>(val), val.length());

	return *this;
}

auto out_stream::operator << (i8 const* val) -> out_stream& {
	this->write(val, strlen(val));

	return *this;
}

auto out_stream::operator << (f32 val) -> out_stream& {
	i8 chars[256] = {};

	dtoa(static_cast<f64>(val), chars, 10);

	this->write(chars, strlen(chars));

	return *this;
}

auto out_stream::operator << (f64 val) -> out_stream& {
	i8 chars[256] = {};

	dtoa(val, chars, 10);

	this->write(chars, strlen(chars));

	return *this;
}

auto in_stream::operator >> (string& val) -> in_stream& {
	vec<u8> data;

	bool ret = false;

	while(!ret) 
	{
		this->flush();
		while(this->buffer.length() > 0) 
		{
			u8 byte = this->buffer.pop();

			if (byte == '\r') 
			{
				ret = true;
				break;
			} 
			else if(byte == '\0') 
			{
				continue;
			} 
			else 
			{
				out << reinterpret_cast<i8 const*>(&byte) << "\r";
				data.push(byte);
			}
		}
	}

	out << endl;
	
	data.push('\0');

	u8 const* bytes = static_cast<u8 const*>(data);

	i8 const* chars = reinterpret_cast<i8 const*>(bytes);

	val = string(chars);

	return *this;
}
