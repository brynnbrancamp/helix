/* vim: set ft=cpp: */

#include <traits>

namespace helix
{
	template<typename...>
	struct variant;

	template<usize, typename...>
	struct variadic_union;

	template<usize index, typename head>
	struct variadic_union<index, head>
	{
		union
		{
			alignas(head) const usize type;
			alignas(head) unsigned char bytes[sizeof(usize) + sizeof(head)];
		};

		variadic_union(head value)
		{
			this->type = index;
			reinterpret_cast<head*>(sizeof(usize) + this->bytes)[0] = value;
		}

		variadic_union(const head& value) : variadic_union(value)
		{
		}
		
		variadic_union(head&& value) : variadic_union(move(value))
		{
		}

		~variadic_union()
		{
			if(index == this->type)
			{
				reinterpret_cast<head*>(sizeof(usize) + this->bytes)->~head();
			}
		}

		template<typename visitor, typename... x>
		friend void visit(visitor, variant<x...>&&);

		template<typename visitor>
		void visit(visitor fn)
		{
			if(index == this->type) 
			{
				fn(reinterpret_cast<head*>(sizeof(usize) + this->bytes)[0]);
			}
		}
	};

	template<usize index, typename head, typename... tail>
	struct variadic_union<index, head, tail...>
	{
		union
		{
			alignas(head) const usize type;
			alignas(head) unsigned char bytes[sizeof(usize) + sizeof(head)];
			variadic_union<index + 1, tail...> rest;
		};
		
		template
		<
			typename data,
			typename = enable_if<eq<data, head> || contains<data, tail...>()>
		>
		variadic_union(data value)

		{
			this->type = type_index<data, head, tail...>();
			reinterpret_cast<data*>(sizeof(usize) + this->bytes)[0] = value;
		}
		
		template
		<
			typename data,
			typename = enable_if<eq<data, head> || contains<data, tail...>()>
		>
		variadic_union(const data& value) : variadic_union(value)
		{
		}

		template
		<
			typename data,
			typename = enable_if<eq<data, head> || contains<data, tail...>()>
		>
		variadic_union(data&& value) : variadic_union(move(value))
		{
		}

		~variadic_union();

		template<typename visitor, typename... x>
		friend void visit(visitor, variant<x...>&&);	
		
		template<typename visitor>
		void visit(visitor fn)
		{
			if(index == this->type) 
			{
				fn(reinterpret_cast<head*>(sizeof(usize) + this->bytes)[0]);
			}
			else
			{
				rest.visit(fn);
			}
		}
	};
		
	template<usize index, typename head, typename... tail>
	variadic_union<index, head, tail...>::~variadic_union()
	{
		usize type = reinterpret_cast<usize*>(this->bytes)[0];
		if(index == type)
		{
			reinterpret_cast<head*>(sizeof(usize) + this->bytes)->~head();
		}
		else
		{
			this->rest.~variadic_union<index + 1, tail...>();
		}
	}
	
	template<typename... data>
	class variant
	{	
	public:
		template
		<
			typename item, 
			typename = enable_if<contains<item, data...>()>
		>
		variant(const item& value) : variant(value) 
		{
			this->value = variadic_union(value);
		}
		
		~variant()
		{
			this->value.~variadic_union<0, data...>();
		}

		template<typename visitor, typename... x>
		friend void visit(visitor, variant<x...>&&);
	private:
		union 
		{
			variadic_union<0, data...> value;
		};
	};

	template<typename visitor, typename... data>
	void visit(visitor fn, variant<data...>&& var)
	{
		var.value.visit(fn);
	}
};
