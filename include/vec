/* vim: set ft=cpp: */
#pragma once

#include <prelude>
#include <sys>
#include <math>
#include <Windows.h>

template <typename item>
class vec
{
public:
	vec() : vec(0)
	{
	}

	vec(usize capacity) : 
		capacity(capacity),
		len(0),
		data(nullptr)
	{
		if(capacity == 0) 
		{
			return;
		}	

		this->data = alloc<item>(capacity);
	}

	~vec()
	{
		dealloc(this->data, this->capacity);
	}

	vec(const vec& other) : vec(other.data) {}

	auto length() const -> usize
	{
		return this->len;
	}

	vec& operator =(const vec& other)
	{
		if (this == &other)
			return *this;

		this->clear();
		this->extend(other);

		return *this;
	}

	auto push(item element)
	{
		if(capacity == 0)
		{
			this->data = alloc<item>(1);
			this->capacity = 1;
		} else if(capacity == len) {
			//temporary
			usize new_capacity = 1024; 
			this->data = realloc(this->data, this->capacity, new_capacity);
			this->capacity = new_capacity;
		}

		this->data[this->len++] = element;
	}

	auto extend(const vec& other) {
		for(usize i = 0; i < other.length(); i++)
		{
			this->push(other[i]);
		}
	}

	auto pop() -> item
	{
		return this->data[this->len--];
	}
	
	auto operator [](usize index) const -> item& 
	{
		if(index >= this->len)
		{
			throw exception::out_of_bounds();
		}

		return this->data[index];
	}

	auto clear()
	{
		this->len = 0;
	}
	
	operator item*() const
	{
		return this->data;
	}
	
	operator item const*() const
	{
		return this->data;
	}
private:
	usize capacity;
	usize len;
	item* data;
};
