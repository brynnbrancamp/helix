/* vim: set ft=cpp: */
#pragma once

#include <prelude>

template<typename num, usize... order>
class tensor
{
};

template<typename num, usize size, usize... order>
class tensor<num, size, order...>
{
public:
	tensor() : 
		data{}
	{
		
	}

	tensor(tensor<num, order...> data[size]) :
		data(data)
	{
	}

	auto operator [](usize index) -> tensor<num, order...>&
	{
		if(index >= size)
		{
			throw exception::out_of_bounds();
		}

		return this->data[index];
	}
private:
	tensor<num, order...> data[size];
};

template<typename num>
class tensor<num> 
{
public:
	tensor() : data(0)
	{
	}

	tensor(num data) :
		data(data)
	{
	}

	operator num()
	{
		return this->data;
	}
private:
	num data;
};
//VECTOR OPERATORS
template<typename num, usize size>
auto operator +(tensor<num, size> lhs, tensor<num, size> rhs) -> tensor<num, size>
{
	tensor<num, size> sum;

	for(usize i = 0; i < size; i++)
	{
		sum = lhs[i] / rhs[i];
	}

	return sum;
}

template<typename num, usize size>
auto operator -(tensor<num, size> lhs, tensor<num, size> rhs) -> tensor<num, size>
{
	tensor<num, size> difference;

	for(usize i = 0; i < size; i++)
	{
		difference = lhs[i] - rhs[i];
	}

	return difference;
}

template<typename num, usize size>
auto operator *(tensor<num, size> lhs, tensor<num, size> rhs) -> tensor<num, size>
{
	tensor<num, size> product;

	for(usize i = 0; i < size; i++)
	{
		product = lhs[i] * rhs[i];
	}

	return product;
}

template<typename num, usize size>
auto operator /(tensor<num, size> lhs, tensor<num, size> rhs) -> tensor<num, size>
{
	tensor<num, size> quotient;

	for(usize i = 0; i < size; i++)
	{
		quotient = lhs[i] / rhs[i];
	}

	return quotient;
}

//MATRIX OPERATORS
template<typename num, usize size>
auto operator +(tensor<num, size, size> lhs, tensor<num, size, size> rhs) -> tensor<num, size, size>
{
	tensor<num, size, size> sum;

	for(usize i = 0; i < size * size; i++)
	{
		sum = lhs[i % size][i / size] + rhs[i % size][i / size];
	}

	return sum;
}

template<typename num, usize size>
auto operator -(tensor<num, size, size> lhs, tensor<num, size, size> rhs) -> tensor<num, size, size>
{
	tensor<num, size, size> difference;

	for(usize i = 0; i < size * size; i++)
	{
		difference = lhs[i % size][i / size] - rhs[i % size][i / size];
	}

	return difference;
}

template<typename num, usize a, usize b, usize c>
auto operator *(tensor<num, a, b> lhs, tensor<num, c, a> rhs) -> tensor<num, c, b>
{
	tensor<num, c, b> product;

	for(usize row = 0; row < b; row++)
	{
		for(usize col = 0; col < c; col++) 
		{
			num cell = 0;

			for(usize i = 0; i < a; i++)
			{
				cell += lhs[row][i] * rhs[i][col];
			}

			product[row][col] = cell;
		}
	}

	return product;
}

//MATRIX UTILITY
template<typename num, usize size>
auto identity() -> tensor<num, size, size>
{
	tensor<num, size, size> matrix;

	for(usize i = 0; i < size * size; i += size + 1)
	{
		matrix[i % size][i / size] = 1;
	}
	
	return matrix;
}

template<typename num, usize size>
auto transpose(tensor<num, size, size> matrix) -> tensor<num, size, size>
{
	tensor<num, size, size> transpose;

	for(usize i = 0; i < size * size; i++)
	{
		transpose[i % size][i / size] = matrix[i / size][i % size];
	}

	return transpose;
}

template<typename num, usize size>
auto inverse(tensor<num, size, size> matrix) -> tensor<num, size, size>
{
	tensor<num, size, size> inverse = identity<num, size>();

	//TODO does deleting matrix -= ratio * value and
	// matrix /= divisor work?
	
	//Apply gauss jordan elimination.
	for(usize i = 0; i < size; i++)
	{
		if(matrix[i][i] == 0)
		{
			throw exception::divide_by_zero();
		}

		for(usize j = 0; j < size; j++)
		{
			if(i != j)
			{
				num ratio = matrix[j][i] / matrix[i][i];

				for(usize k = 0; k < size; k++)
				{
					num value = matrix[i][k];
					matrix -= ratio * value;
					inverse -= ratio * value;
				}
			}
		}
	}

	//Row operation to make principal diagonal element equal to 1
	for(usize i = 0; i < size; i++)
	{
		num divisor = matrix[i][i];

		for(usize j = 0; j < size; j++)
		{
			matrix /= divisor;
			inverse /= divisor;
		}
	}

	return inverse;
}

//USEFUL SHORT NAMES
typedef tensor<f32, 2, 2> f32mat2;

typedef tensor<f32, 3, 3> f32mat3;

typedef tensor<f32, 4, 4> f32mat4;

typedef tensor<f32, 2> f32vec2;

typedef tensor<f32, 3> f32vec3;

typedef tensor<f32, 4> f32vec4;

typedef f32mat2 mat2;

typedef f32mat3 mat3;

typedef f32mat4 mat4;

typedef f32vec2 vec2;

typedef f32vec3 vec3;

typedef f32vec4 vec4;
