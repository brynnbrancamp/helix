/* vim: set ft=cpp: */

#include <window>
#include <tensor>

#include <Windows.h>

namespace helix
{
	static vec<window_event> event_buffer;

	LRESULT wnd_proc(HWND hwnd, UINT msg, WPARAM w_param, LPARAM l_param)
	{
		switch(msg)
		{
		case WM_CLOSE:
		{
			event_buffer.push(window_event(window_event_close_requested()));

			return true;
		}
		case WM_KEYDOWN:
		{
			option<key_code> key = convert_native_code(w_param);
			
			if(key.is_none())
				return true;
			
			event_buffer.push(window_event(window_event_key {
				.pressed = true,
				.key = key.unwrap()
			}));

			return true;
		}
		case WM_KEYUP:
		{
			option<key_code> key = convert_native_code(w_param);
			
			if(key.is_none())
				return true;

			event_buffer.push(window_event(window_event_key {
				.pressed = false,
				.key = key.unwrap()
			}));

			return true;
		}
		case WM_MOVE:
		{
			event_buffer.push(window_event(window_event_pointer {
				.position = v2<usize>
				(
					static_cast<usize>(LOWORD(l_param)), 
					static_cast<usize>(HIWORD(l_param))
				)
			}));

			return true;
		}
		case WM_SETFOCUS:
		{
			event_buffer.push(window_event(window_event_focus {
				.active = true
			}));

			return true;
		}
		case WM_KILLFOCUS:
		{
			event_buffer.push(window_event(window_event_focus {
				.active = false
			}));

			return true;
		}
		case WM_SIZE:
		{
			event_buffer.push(window_event(window_event_resize {
				.resolution = v2<usize>
				(
					static_cast<usize>(LOWORD(l_param)), 
					static_cast<usize>(HIWORD(l_param))
				)
			}));

			return true;
		}
		case WM_SIZING:
		{
			RECT const* client_area = reinterpret_cast<RECT const*>(l_param);
			event_buffer.push(window_event(window_event_resize {
				.resolution = v2<usize>
				(
					static_cast<usize>(client_area->right - client_area->left), 
					static_cast<usize>(client_area->bottom - client_area->top)
				)
			}));

			return true;
		}
		case WM_DESTROY:
		{
			PostQuitMessage(0);
		}
		}

		return DefWindowProcA(hwnd, msg, w_param, l_param);
	}

	struct window_data
	{
		HWND hwnd;
		WINDOWPLACEMENT wpc;
		LONG style;
		LONG style_ex;
	};

	window::window()
	{
		this->data = new window_data;

		const i8 class_name[] = "Helix";

		WNDCLASS wc = { sizeof(WNDCLASS) };

		wc.lpfnWndProc = wnd_proc;
		wc.lpszClassName = class_name;

		RegisterClass(&wc);

		const i8 window_name[] = "Window";

		this->data->hwnd = CreateWindowEx
		(
			0,
			class_name,
			window_name,
			WS_OVERLAPPEDWINDOW,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			0,
			0,
			0,
			0
		);

		if(this->data->hwnd == nullptr)
		{
			throw exception::system_error();
		}
	}

	window::~window()
	{
		DestroyWindow(this->data->hwnd);

		delete this->data;
	}

	auto window::poll() -> option<window_event>
	{
		MSG msg = {};

		while(PeekMessageA(&msg, this->data->hwnd, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessageW(&msg);
		}

		if(event_buffer.length() == 0)
		{
			return option<window_event>();
		}

		return option(event_buffer.pop());
	}

	auto window::set_visible(bool toggle) -> window&
	{
		this->visible = toggle;

		ShowWindow(this->data->hwnd, this->visible ? SW_SHOW : SW_HIDE);

		return *this;
	}

	auto window::set_fullscreen(bool toggle) -> window&
	{
		if(this->fullscreen && !toggle) 
		{
			SetWindowLong(this->data->hwnd, GWL_STYLE, this->data->style);
			SetWindowLong(this->data->hwnd, GWL_EXSTYLE, this->data->style_ex);
			ShowWindow(this->data->hwnd, SW_SHOWNORMAL);
			SetWindowPlacement(this->data->hwnd, &this->data->wpc);
		}
		else if(!this->fullscreen && toggle)
		{
			GetWindowPlacement(this->data->hwnd, &this->data->wpc );
			if (this->data->style == 0 )
				this->data->style = GetWindowLong(this->data->hwnd, GWL_STYLE);
			if (this->data->style_ex == 0 )
				this->data->style_ex = GetWindowLong(this->data->hwnd, GWL_EXSTYLE);

			LONG new_style =this->data->style;
			new_style &= ~WS_BORDER;
			new_style &= ~WS_DLGFRAME;
			new_style &= ~WS_THICKFRAME;

			LONG new_style_ex = this->data->style_ex;
			new_style_ex &= ~WS_EX_WINDOWEDGE;

			SetWindowLong(this->data->hwnd, GWL_STYLE, new_style | WS_POPUP);
			SetWindowLong(this->data->hwnd, GWL_EXSTYLE, new_style_ex | WS_EX_TOPMOST);
			ShowWindow(this->data->hwnd, SW_SHOWMAXIMIZED);	
		}

		this->fullscreen = toggle;

		return *this;
	}

	auto window::set_title(string str) -> window&
	{
		SetWindowTextA(this->data->hwnd, static_cast<i8 const*>(str));

		return *this;
	}

	auto window::set_resolution(v2<usize> resolution) -> window&
	{
		
		SetWindowPos
			(
			 this->data->hwnd,
			 0,
			 0,
			 0,
			 static_cast<i32>(resolution[0]),
			 static_cast<i32>(resolution[1]),
			 SWP_NOMOVE
			);
		return *this;
	}

	auto window::get_visible() -> bool
	{
		return this->visible;
	}

	auto window::get_fullscreen() -> bool
	{
		return this->fullscreen;
	}

	auto window::get_title() -> string
	{
		i8 data[256] = {};

		GetWindowTextA(this->data->hwnd, data, 256);

		string str(data);

		return str;
	}

	auto window::get_resolution() -> v2<usize>
	{
		RECT size;

		GetClientRect(this->data->hwnd, &size);

		v2<usize> resolution
		(
			static_cast<usize>(size.right),
			static_cast<usize>(size.bottom)
		);

		return resolution;
	}
}
